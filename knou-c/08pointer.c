#include <stdio.h>
#pragma warning(disable:4996)


void main081() {
	
	int a = 100;
	int array[5] = { 1,2,3,4,5 };
	//int* b = 110; // 에러 포인터변수b  //포인터 변수 b에는 주소값을 넣아야지 정수값을 넣으면 안된다 

	int* c; //포인터변수c     (c는 주소를 가지고있는 포인터변수라서 c에는 주소를 넣어줘야함)
	c = &a;//  (c는 주소를 가지고있는 포인터변수라서 c에는 주소를 넣어줘야함)

	int d;
	d = *c;   // *c: c에 적힌 주소에 해당하는 값 이니까 a의 값이 나올것. (c가 가리키는곳의 내용)   // int* b 의 별과는 다른개념이다 이것은 포인터변수를 선언한다는뜻. 


	printf("a의 주소:  %p\n", &a);
	printf("a의 값:  %d\n", a);

	printf("array의 주소:  %p\n", &array);
	printf("array의 주소(array의 값은 주소값이다):  %p\n", array);
	printf("array의 0인덱스의 주소 값:  %p\n", &array[0]);
	printf("array의 0인덱스 값:  %d\n", array[0]);


	printf("c의 주소:  %p\n", &c);//포인터변수도 자기의 주소가 있을테니까 c의 주소가 출력됨.
	printf("포인터 변수 c의 값(a의 주소):  %p\n", c);
	printf("c의 값:  %d\n", c);//에러 포인터 변수 c는 주소값이 적혀있는데 ,  정수로 출력하면 안됨.

	printf("d의 주소:  %p\n", &d);
	printf("d의 값:  %d\n", d);


}



void main082() {
	
	int* e;
	int i =4;

	e = &i; //(필수) e를 i의 주소로 초기화

	*e = 33; // 이제 e가 가리키는 위치(변수 i)에 i의 값을 할당

	printf("e의 주소: %p\n", (void*)&e); // e 자체의 주소를 출력
	printf("e가 가리키는 주소: %p\n", (void*)e); // e가 가리키는 주소(변수 i의 주소)를 출력
	printf("e가 가리키는 값: %d\n", *e); // e를 통해 접근한 i의 값을 출력


}
void main083() {

	int* e;
	int i = 4;

	e = &i; //(필수) e를 i의 주소로 초기화

	*e = 33; // 이제 e가 가리키는 위치(변수 i)에 i의 값을 할당

	printf("e의 주소: %p\n", (void*)&e); // e 자체의 주소를 출력
	printf("e가 가리키는 주소: %p\n", (void*)e); // e가 가리키는 주소(변수 i의 주소)를 출력
	printf("e가 가리키는 값: %d\n", *e); // e를 통해 접근한 i의 값을 출력
}


//void*포인터
void main084() {
	int a = 100;
	char b = 'b';

	void* e=NULL;

	e =(char*)&b;
	/* (char*)&b 이 캐스팅은 b의 주소를 가리키는 포인터가 char 타입의 데이터를 가리키도록 하겠다는 것을 의미합니다. 
	즉, 이 주소를 통해 메모리를 엑세스할 때, char 크기의 단위로 엑세스하겠다는 의미입니다.
	char 타입은 보통 1바이트를 차지하므로, 이는 메모리의 해당 주소에서 1바이트 단위로 데이터를 읽거나 쓰겠다는 것을 나타냅니다.*/

	printf("b의 주소: %p\n", &b); // e 자체의 주소를 출력
	printf("e의 주소: %p\n", &e); // e 자체의 주소를 출력
	printf("e가 가리키는 주소: %p\n", e); // e가 가리키는 주소(변수 i의 주소)를 출력
	printf("e가 가리키는 값: %c\n", *(char*)e); // e를 통해 접근한 i의 값을 출력
	// *((char*)e)는 e를 char* 타입으로 캐스팅하고, 그 결과를 역참조하여 e가 가리키는 메모리의 값을 char 타입으로 읽습니다

	/*
*e는 불가능하다
e =(char*)&b; 구문은 실제로 e가 가리키는 주소를 char* 타입의 주소로 캐스팅하고 있습니다.
그러나 e 자체의 타입은 여전히 void*입니다. C언어에서 void* 타입은 범용 포인터 타입으로, 어떤 타입의 주소도 저장할 수 있지만, void* 타입의 포인터를 통해 직접 데이터에 접근(역참조)하는 것은 허용되지 않습니다.
따라서 e를 역참조하기 위해서는 명시적으로 해당 타입의 포인터로 다시 캐스팅해야 합니다.
e =(char*)&b; 구문은 e에 b의 주소를 char*로 캐스팅해서 저장하는 것이지만, 이는 단지 e에 어떤 주소를 저장하기 위한 중간 단계일 뿐, e의 실제 타입을 변경하지 않습니다.
e의 타입은 선언될 때 정해진 void*로 고정되어 있으며, 이후에는 변하지 않습니다.
따라서, e가 가리키는 값을 접근하려면, 역참조하기 전에 e를 해당 데이터 타입의 포인터로 명시적으로 캐스팅해야 합니다. 예를 들어, e가 char 타입의 데이터를 가리킨다면, 다음과 같이 역참조할 수 있습니다:

	*/

	e = (int*)&a;
	
	//*e = 33; //에러
	/*
	void* 포인터는 "타입 없는" 포인터로, 어떤 타입의 객체의 주소도 저장할 수 있지만, 
	직접적인 역참조(dereferencing)나 포인터 산술 연산이 허용되지 않습니다. 
	즉, void* 포인터로는 메모리에 직접 값을 쓰거나 읽을 수 없습니다.
	*/


	printf("a의 주소: %p\n", &a); // e 자체의 주소를 출력
	printf("e의 주소: %p\n", &e); // e 자체의 주소를 출력
	printf("e가 가리키는 주소: %p\n", e); // e가 가리키는 주소(변수 i의 주소)를 출력
	printf("e가 가리키는 값: %d\n", *(int*)e); // e를 통해 접근한 i의 값을 출력

}