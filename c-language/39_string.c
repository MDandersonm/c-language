#define _CRT_SECURE_NO_WARNINGS // scanf 보안 경고로 인한 컴파일 에러 방지
#include <stdio.h>

int main39()
{
    char str[] = "Beethoven\n9th\nSymphony";  // 문자 배열로 문자열을 저장
    printf("%s\n", str);

    char s1[10];    // 크기가 10인 char형 배열을 선언

    printf("문자열을 입력하세요: ");
    scanf("%s", s1);     // 표준 입력을 받아서 배열 형태의 문자열에 저장
    // & (주소 연산자)를 사용하지 않는 이유는 문자열 이름 자체가 해당 문자열의 시작 주소를 나타내기 때문입니다.
    //배열 이름, 예를 들면 s1,은 배열의 첫 번째 원소의 주소를 나타냅니다. 따라서 s1는 &s1[0]과 동일한 주소값을 가집니다.

    printf("%s\n", s1);  // 문자열의 내용을 출력

    
    /*
    getchar()는 C 표준 라이브러리 함수로, 표준 입력(대부분 키보드)에서 한 문자를 읽어들이는 기능을 합니다. 읽어들인 문자를 반환합니다.
while (getchar() != '\n'); 구문은 표준 입력 버퍼에 남아 있는 문자들을 순차적으로 읽어들이면서, 개행 문자('\n')를 만날 때까지 계속 반복하는 것을 의미합니다.
여기서 '\n'은 개행 문자로, 보통 Enter 키를 눌렀을 때 입력되는 문자입니다.
이 구문의 주요 용도는 이전의 입력에서 버퍼에 남아있는 문자들, 특히 개행 문자를 제거하기 위해서 사용됩니다. 
scanf와 같은 함수로 입력을 받을 때, 입력의 끝을 알리는 Enter 키를 누르면, 입력된 데이터와 함께 개행 문자도 버퍼에 남게 됩니다. 
이 후의 scanf나 다른 입력 함수들이 그 개행 문자를 바로 읽어서 원치 않는 동작을 할 수 있기 때문에, 이를 방지하기 위해 버퍼를 비워주는 역할로 while (getchar() != '\n');를 사용하는 것입니다.
    */
    
    while (getchar() != '\n'); // 버퍼 비우기




    //scanf 함수에서 서식 지정자를 "%[^\n]s"와 같이 지정하면 공백까지 포함하여 문자열을 입력받을 수 있습니다.
    char s2[30];

    printf("공백을 포함한 문자열을 입력하세요: ");
    scanf("%[^\n]s", s2);    // 공백까지 포함하여 문자열 입력받기

    printf("%s\n", s2);



    char* s11 = "Hello, world!";       // char 포인터에 문자열의 메모리 주소를 저장
    char s12[20] = "Hello, world!";    // char 배열에 문자열 저장
    char s13[] = "Hello, world!";      // char 배열에 문자열 저장(배열의 크기 생략)
    
    //이미 선언된 배열에는 문자열을 할당할 수 없습니다.

    //문자열 포인터에 문자열 리터럴을 할당한 뒤에는 인덱스로 접근하여 문자(요소)를 변경할 수 없습니다(문자열 리터럴이 있는 메모리 주소는 읽기 전용). 
    // 하지만 문자 배열은 인덱스로 접근하여 문자를 변경할 수 있습니다(배열에 문자열이 복사됨).
    //char* s1 = "Hello";       // 문자열 포인터에 문자열 리터럴 할당(읽기 전용 메모리를 가리킴)
   // s1[0] = 'A';              // 실행 에러: 문자를 변경할 수 없음

    char s22[10] = "Hello";    // 문자 배열에 문자열 리터럴 할당(배열에 문자열이 복사됨)
    s22[0] = 'A';              // 문자를 변경할 수 있음


    return 0;
}